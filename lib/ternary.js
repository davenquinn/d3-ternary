// Generated by CoffeeScript 1.8.0
(function() {
  var angles, line, path;

  path = void 0;

  d3.ternary = {};

  line = function(interpolator) {
    if (!interpolator) {
      interpolator = 'linear';
    }
    return path = d3.svg.line().x(function(d) {
      return d[0];
    }).y(function(d) {
      return d[1];
    }).interpolate(interpolator);
  };

  angles = [0, 120, 240];

  d3.ternary.graticule = function() {
    var gratAxis, graticule, majorInterval, majorTicks, minorInterval, minorTicks;
    majorInterval = 0.1;
    minorInterval = null;
    majorTicks = function() {
      var int, start, ticks;
      ticks = [];
      int = majorInterval;
      start = int;
      while (start < 1) {
        ticks.push(start);
        start += int;
      }
      return ticks;
    };
    minorTicks = function() {
      var start, ticks;
      ticks = [];
      if (minorInterval == null) {
        return ticks;
      }
      start = minorInterval;
      while (start < 1) {
        if (start % majorInterval !== 0) {
          ticks.push(start);
        }
        start += minorInterval;
      }
      return ticks;
    };
    gratAxis = d3.svg.axis().tickValues(majorTicks());
    graticule = function(plot) {
      var axisGraticule;
      gratAxis.scale(plot.scale);
      axisGraticule = function(axis, i) {
        var container, sel;
        container = d3.select(this);
        sel = container.selectAll("path.minor").data(minorTicks());
        sel.enter().append("path").attr({
          "class": "minor",
          d: plot.rule(i)
        });
        sel = container.selectAll("path.major").data(majorTicks());
        return sel.enter().append("path").attr({
          "class": "major",
          d: plot.rule(i)
        });
      };
      return plot.axes().selectAll(".graticule").data([gratAxis, gratAxis, gratAxis]).enter().append("g").attr({
        "class": "graticule"
      }).each(axisGraticule);
    };
    graticule.axis = function() {
      return gratAxis;
    };
    graticule.majorInterval = function(d) {
      if (!d) {
        return majorInterval;
      }
      majorInterval = d;
      return graticule;
    };
    graticule.minorInterval = function(d) {
      if (!d) {
        return minorInterval;
      }
      minorInterval = d;
      return graticule;
    };
    return graticule;
  };

  d3.ternary.scalebars = function() {
    var adjustText, baryAxis, scalebar;
    baryAxis = d3.svg.axis().tickSize(10).tickFormat(d3.format("%")).tickValues([.2, .4, .6, .8]).orient("top");
    adjustText = function(d, i) {
      if (i !== 1) {
        return;
      }
      return d3.select(this).selectAll("text").attr({
        transform: function(d) {
          var y;
          y = d3.select(this).attr("y");
          return "translate(0 " + (-y) + ") rotate(-180 0 " + (2 * y) + ")";
        }
      });
    };
    scalebar = function(plot) {
      var b_axes, offs, r;
      baryAxis.scale(plot.scale);
      r = plot.radius();
      offs = plot.center();
      return b_axes = plot.axes().selectAll(".bary-axis").data(angles).enter().append("g").attr({
        "class": "bary-axis",
        transform: function(d, i) {
          var x, y;
          x = offs[0];
          y = offs[1];
          return "rotate(" + (60 + i * 120) + " " + x + " " + y + ") translate(0 " + (r / 2) + ")";
        }
      }).call(baryAxis).each(adjustText);
    };
    return scalebar;
  };

  d3.ternary.vertexLabels = function(labels) {
    var pad, rotate, sel;
    sel = null;
    rotate = [0, 60, -60];
    pad = 20;
    labels = function(plot) {
      var data, offs, radius;
      sel = plot.axes().selectAll(".vertex-label");
      offs = plot.center();
      radius = plot.radius();
      data = labels.map(function(l, i) {
        return {
          label: l,
          angle: angles[i]
        };
      });
      sel.data(data).enter().append("text").text(function(d) {
        return d.label;
      }).attr({
        dy: ".35em",
        "text-anchor": "middle",
        "class": "vertex-label",
        transform: function(d, i) {
          var a, x, y;
          a = -d.angle * Math.PI / 180;
          console.log(a);
          x = offs[0] + Math.sin(a) * (radius + pad);
          y = offs[1] - Math.cos(a) * (radius + pad);
          return "translate(" + x + "," + y + ")rotate(" + rotate[i] + ")";
        }
      });
      return sel;
    };
    return labels;
  };

  d3.ternary.neatline = function() {
    var createPoint, neatline;
    createPoint = function(i) {
      var a;
      a = [0, 0, 0];
      a[i] = 1;
      return a;
    };
    neatline = function(plot) {
      var el, i;
      el = plot.node().append("polygon");
      return el.datum((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 2; i = ++_i) {
          _results.push(createPoint(i));
        }
        return _results;
      })()).attr({
        "class": "neatline",
        points: function(d) {
          var di;
          di = d.map(function(c) {
            var i;
            i = plot.point(c);
            return i.join(",");
          });
          return di.join(" ");
        }
      });
    };
    return neatline;
  };

  d3.ternary.plot = function() {
    var T, axes, callOnCreate, height, margin, outerHeight, outerWidth, plot, radius, rescaleView, scale, svg, width;
    outerWidth = 500;
    outerHeight = 500;
    margin = {
      top: 50,
      bottom: 50,
      left: 50,
      right: 50
    };
    radius = null;
    height = null;
    width = null;
    svg = null;
    axes = null;
    plot = null;
    callOnCreate = [];
    scale = d3.scale.linear().domain([0, 1]).range([0, 1]);
    rescaleView = function() {
      var center;
      width = outerWidth - margin.left - margin.right;
      height = outerHeight - margin.top - margin.bottom;
      radius = width / Math.sqrt(3);
      center = [width / 2, radius];
      if (svg == null) {
        return;
      }
      svg.attr({
        transform: "translate(" + margin.left + "," + margin.top + ")",
        width: width,
        height: height
      });
      d3.select(svg.node().parentElement).attr({
        width: outerWidth,
        height: outerHeight
      });
      return scale.range([0, 400]);
    };
    T = function(el) {
      var svg_;
      svg_ = el.selectAll("svg").data([null]);
      svg = svg_.enter().append("svg").append("g");
      axes = svg.append('g').attr('id', 'axes');
      plot = svg.append('g').attr('id', 'plot');
      rescaleView();
      callOnCreate.forEach(function(f) {
        return f(T);
      });
      return callOnCreate = [];
    };
    T.node = function() {
      return svg;
    };
    T.axes = function() {
      return axes;
    };
    T.plot = function() {
      return plot;
    };
    T.call = function(f) {
      if (svg != null) {
        f(T);
      } else {
        callOnCreate.push(f);
      }
      return T;
    };
    T.scale = scale;
    T.margin = function(m) {
      if (m == null) {
        return margin;
      }
      margin = m;
      return T;
    };
    T.point = function(coords) {
      var normalized, pos, sum;
      pos = [0, 0];
      sum = d3.sum(coords);
      if (sum !== 0) {
        normalized = coords.map(function(d) {
          return d / sum;
        });
        pos[0] = scale(normalized[1] + normalized[2] / 2);
        pos[1] = scale(Math.sqrt(3) / 2 * (normalized[0] + normalized[1]));
      }
      return pos;
    };
    T.path = (function(_this) {
      return function(coordsList, accessor, interpolator) {
        var positions;
        line(interpolator);
        if (!accessor) {
          accessor = function(d) {
            return d;
          };
        }
        positions = coordsList.map(function(d) {
          return T.point(accessor(d));
        });
        return path(positions) + "Z";
      };
    })(this);
    T.rule = function(axis) {
      return function(value) {
        var ends;
        ends = [];
        if (axis === 0) {
          ends = [[value, 0, 1 - value], [value, 1 - value, 0]];
        } else if (axis === 1) {
          ends = [[0, value, 1 - value], [1 - value, value, 0]];
        } else if (axis === 2) {
          ends = [[0, 1 - value, value], [1 - value, 0, value]];
        }
        return T.path(ends);
      };
    };
    T.getValues = function(pos) {
      var a, b, c;
      pos = pos.map(scale.inverse);
      c = 1 - pos[1];
      b = pos[0] - c / 2;
      a = y - b;
      return [a, b, c];
    };
    T.range = function(range) {
      return T;
    };
    T.radius = function(r) {
      if (r == null) {
        return radius;
      }
      return T;
    };
    T.center = function() {
      return [width / 2, radius];
    };
    return T;
  };

}).call(this);
