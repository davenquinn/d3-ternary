<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quick test new d3-ternary</title>
  </head>
  <body>
    <svg width="600" height="600" id="ternary"></svg>
    <!-- <script type="module" src="./dist/d3-ternary.js"></script> -->
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <script type="module">
      import ternary from "./src/ternary.js";
      import ternaryPlot from "./src/ternaryPlot.js";

      const globalRadius = 250;
      const width = 600;
      const height = 600;
      const yOffset = globalRadius / 4;

      const ternaryCoords = ternary()
        .a((d) => d.agriculture)
        .b((d) => d.industry)
        .c((d) => d.service);

      console.log(ternaryPlot);

      const demoTernaryPlot = ternaryPlot(ternaryCoords)
        .radius(globalRadius)
        .labels(["Agriculture (A)", "Industry (B)", "Service (C)"])
        .gridLineCounts([20, 20, 20])
        .tickCounts([10, 10, 10])
        .domains([
          [0, 0.7],
          [0, 0.7],
          [0.3, 1],
        ]); // works✅
      // .domains([[20, 60], [0, 40], [40, 80]]) // works✅
      // .domains([[100, 0], [100, 0], [100, 0]])

      const axisLabels = (g, labels) =>
        g
          .append("g")
          .attr("class", "labels")
          .attr("font-size", 16)
          .selectAll("text")
          .data(labels)
          .join("text")
          .attr("dy", (d, i) => (i === 2 ? "-0.5em" : ".5em"))
          .attr(
            "transform",
            (d, i) => `translate(${d.position})rotate(${d.labelAngle})`
          )
          .attr("text-anchor", "middle")
          .text((d) => d.label);

      const drawTicks = (g, ticks) =>
        g
          .selectAll("g")
          .data(
            (d) => d,
            (d) => d.tick
          )
          .join(
            (enter) => {
              const tickGroups = enter
                .append("g")
                .attr("class", "tick")
                .attr("transform", (d) => `translate(${d.position})`);

              tickGroups
                .append("text")
                .attr("text-anchor", (d) => d.textAnchor)
                .attr("transform", (d) => `rotate(${d.angle})`)
                .attr(
                  "dx",
                  (d) => (-d.size - 5) * (d.textAnchor === "start" ? -1 : 1)
                )
                .attr("dy", ".5em")
                .text((d) => d.tick);

              tickGroups
                .append("line")
                .attr("transform", (d) => `rotate(${d.angle + 90})`)
                .attr("y2", (d) => d.size * (d.textAnchor === "start" ? -1 : 1))
                .attr("stroke", "grey");

              return tickGroups;
            },
            (update) =>
              update
                .attr("fill", "steelblue")
                .attr("transform", (d) => `translate(${d.position})`),
            (exit) => exit.remove()
          );

      const grid = (g, gridLines) =>
        g
          .selectAll("path")
          .data(gridLines)
          .join(
            (enter) =>
              enter
                .append("path")
                .attr("d", (d) => d)
                .attr("stroke", "#e3e3e3")
                .attr("stroke-width", (d, i) => (i & 1 ? 1 : 2)),
            (update) => update.attr("d", (d) => d)
            // theres no exit, lines are only drawn upto 'initial' triangle bounds
          );

      const drawTernaryPlot = (someTernaryPlot) => {
        const svg = d3.select("#ternary");

        const radius = someTernaryPlot.radius();

        const chart = svg
          .append("g")
          .attr("transform", `translate(${width / 2} ${height / 2 + yOffset})`)
          .attr("height", 300)
          .attr("font-family", "sans-serif")
          .attr("id", "chart")
          .on("mousemove", (d) => {
            const [x, y] = d3.pointer(d);
            const inverse = ternaryCoords.invert([x / radius, y / radius]);
          });

        const defs = chart.append("defs");

        const clipPath = defs
          .append("clipPath")
          .attr("id", "trianglePath")
          .append("path")
          .attr("d", someTernaryPlot.triangle());

        // initial triangle
        const trianglePath = chart
          .append("path")
          .attr("d", someTernaryPlot.triangle())
          .attr("fill", "white")
          .attr("stroke", "black")
          .attr("title", "Initial untransformed triangle")
          .attr("stroke-width", 2);

        const projectedTrianglePath = chart
          .append("path")
          .attr("d", someTernaryPlot.triangle())
          .attr("fill", "none")
          .attr("stroke", "crimson")
          .attr("title", " Scaled & translated triangle")
          .attr("stroke-width", 2);

        chart.append("circle").attr("r", 4).attr("fill", "gold");

        const axisLabelsGroup = chart
          .append("g")
          .attr("class", "axis-labels")
          .call(axisLabels, someTernaryPlot.axisLabels());

        const gridLinesPaths = someTernaryPlot
          .gridLines()
          .map((axisGrid) => axisGrid.map(d3.line()).join(" "));

        const gridGroup = chart
          .append("g")
          .attr("class", "grid")
          .call(grid, gridLinesPaths);

        const axisTicksGroups = chart
          .append("g")
          .attr("class", "ternary-ticks")
          .attr("font-size", 10)
          .selectAll("g")
          .data(someTernaryPlot.ticks())
          .join("g")
          .attr("class", "axis-ticks");

        axisTicksGroups.call(drawTicks);

        // data
        const dots = chart
          .append("g")
          .attr("class", "data")
          .attr("clip-path", "url(#trianglePath)")
          .selectAll("circle");
        //   .data(ternaryData)
        //   .join("circle")
        //   .attr("r", 4)
        //   .attr("cx", (d) => d.x)
        //   .attr("cy", (d) => d.y)
        //   .attr("fill", "#444")
        //   .attr("stroke", "#ddd");

        dots.append("title").text(
          (d) => `${d.country}
            Agriculture: ${d.agriculture}
            Industry: ${d.industry}
            Service: ${d.service}`
        );

        // knobs
        chart
          .append("g")
          .selectAll(".knobs")
          .data(
            ternaryCoords.vertices().map((v, i) => ({ position: v, index: i }))
          )
          .join("circle")
          .attr("class", "knobs")
          .attr("r", 5)
          .attr("cx", (d) => d.position[0] * radius)
          .attr("cy", (d) => d.position[1] * radius)
          .attr("fill", "red")
          .call(
            d3
              .drag()
              .on("start", dragStarted)
              .on("drag", draggedKnobs)
              .on("end", dragEnded)
          );

        const zoom = d3.zoom().scaleExtent([1, 100]).on("zoom", zoomed);

        const [tx, ty] = someTernaryPlot.translate();
        const k = someTernaryPlot.scale();

        // We need to sync d3-zoom with the tranform from the partial domain
        const initialTransform = d3.zoomIdentity
          .translate(tx * radius, ty * radius)
          .scale(k);
        chart.call(zoom).call(zoom.transform, initialTransform);

        function dragEnded(event, d, i) {
          // gridGroup.call(grid, someTernaryPlot.gridLines().map(axisGrid => axisGrid.map(d3.line()).join(" ")));
          // ticksGroup.call(ticks, someTernaryPlot.ticks());

          d3.select(this).attr("stroke", null);
        }

        function dragStarted(event, d) {
          d3.select(this).raise().attr("stroke", "black");
        }

        function draggedKnobs(event, d) {
          const { x, y, subject } = event;
          const newVertices = ternaryCoords.vertices();
          newVertices[subject.index] = [x / radius, y / radius];

          ternaryCoords.vertices(newVertices);

          const newTriangle = newVertices.map(([x, y]) => [
            x * radius,
            y * radius,
          ]);
          const newTrianglePath = `M${newTriangle[0]}L${newTriangle[1]}L${newTriangle[2]}Z`;

          projectedTrianglePath.attr("d", newTrianglePath);

          d3.select(this)
            .attr("cx", (d.x = x))
            .attr("cy", (d.y = y));

          dots
            .attr("cx", (d) => ternaryCoords(d)[0] * radius)
            .attr("cy", (d) => ternaryCoords(d)[1] * radius);

          // gridGroup.call(grid, gridLinesPaths);
        }

        function zoomed({ transform }) {
          console.group("'zoomed' called with transform", transform);
          const { x, y, k } = transform;
          console.groupEnd();

          const tx = x / radius,
            ty = y / radius;

          someTernaryPlot.transform({ x: tx, y: ty, k }); // apply transform

          const zoomedDomains = someTernaryPlot.domainsFromVertices(
            ternaryCoords
          ); // pass the transform than call .transform()?
          console.log("zoomedDomains", zoomedDomains);
          someTernaryPlot.setDomains(zoomedDomains);

          // update data
          dots
            .attr("cx", (d) => ternaryCoords(d)[0] * radius)
            .attr("cy", (d) => ternaryCoords(d)[1] * radius);

          // update gridlines and ticks
          const gridLinesPaths = someTernaryPlot
            .gridLines()
            .map((axisGrid) => axisGrid.map(d3.line()).join(" "));
          gridGroup.call(grid, gridLinesPaths);

          axisTicksGroups
            .data(someTernaryPlot.ticks())
            .call(drawTicks, (d) => d);

          const newTriangle = ternaryCoords
            .vertices()
            .map(([x, y]) => [x * radius, y * radius]);
          const newTrianglePath = `M${newTriangle[0]}L${newTriangle[1]}L${newTriangle[2]}Z`;

          projectedTrianglePath.attr("d", newTrianglePath);
        }

        return svg;
      };

      drawTernaryPlot(demoTernaryPlot);
    </script>
  </body>
</html>
