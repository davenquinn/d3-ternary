// https://github.com/davenquinn/d3-ternary#readme v2.0.0 Copyright 2020 Jules Blom
function n(c){let l=500,o=1,a=0,u=0;const s=c.vertices(),[g,k,f]=s;let m=i(g,k),A=i(g,f),d=r(m,g[1]),b=r(A,g[1]),[h,L,C]=s.map((([n,t])=>[n*l,t*l]));const x={label:"A",labelAngle:0,labelOffset:30,gridLine:e(C,h),gridLineCount:20,scale:d3.scaleLinear().domain([0,100]),tickAngle:0,tickCount:15,tickSize:6,tickTextAnchor:"start",vertex:s[0]},p={label:"B",labelAngle:60,labelOffset:30,gridLine:e(h,L),gridLineCount:20,scale:d3.scaleLinear().domain([0,100]),tickAngle:60,tickCount:15,tickSize:6,tickTextAnchor:"end",vertex:s[1]},z={label:"C",labelAngle:-60,labelOffset:30,gridLine:e(L,C),gridLineCount:20,scale:d3.scaleLinear().domain([0,100]),tickAngle:-60,tickCount:15,tickSize:6,tickTextAnchor:"end",vertex:s[2]};return x.conjugate=p,p.conjugate=z,z.conjugate=x,n.axisLabels=function(){return[x,p,z].map((n=>({position:[n.vertex[0]*(l+n.labelOffset),n.vertex[1]*(l+n.labelOffset)],label:n.label,labelAngle:n.labelAngle})))},n.setDomains=function(t){const[e,i,r]=t;return x.scale.domain(e),p.scale.domain(i),z.scale.domain(r),n},n.domains=function(t){if(!arguments.length)return[x.scale.domain(),p.scale.domain(),z.scale.domain()];n.setDomains(t);const e=n.transformFromDomains(t);return n.transform(e),n},n.gridLines=function(){return[x,p,z].map((n=>n.scale.ticks(n.gridLineCount-1).map((t=>[n.gridLine(n.scale(t)),n.conjugate.gridLine(1-n.scale(t))]))))},n.gridLineCounts=function(t){return arguments.length?(x.gridLineCount=t[0],p.gridLineCount=t[1],z.gridLineCount=t[2],n):[x.gridLineCount,p.gridLineCount,z.gridLineCount]},n.ticks=function(){return[x,p,z].map((n=>n.scale.ticks(n.tickCount).map((t=>({tick:t,position:n.gridLine(n.scale(t)),angle:n.tickAngle,size:n.tickSize,textAnchor:n.tickTextAnchor})))))},n.tickAngles=function(t){return arguments.length?(x.tickAngle=t[0],p.tickAngle=t[1],z.tickAngle=t[2],n):[x.tickAngle,p.tickAngle,z.tickAngle]},n.tickCounts=function(t){return arguments.length?Array.isArray(t)?(x.tickCount=t[0],p.tickCount=t[1],z.tickCount=t[2],n):(x.tickCount=p.tickCount=z.tickCount=+t,n):[x.tickCount,p.tickCount,z.tickCount]},n.tickSize=function(t){return arguments.length?Array.isArray(t)?(x.tickSize=t[0],p.tickSize=t[1],z.tickSize=t[2],n):(x.tickSize=p.tickSize=z.tickSize=+t,n):[x.tickSize,p.tickSize,z.tickSize]},n.tickTextAnchors=function(t){return arguments.length?(x.tickTextAnchor=t[0],p.tickTextAnchor=t[1],z.tickTextAnchor=t[2],n):[x.tickTextAnchor,p.tickTextAnchor,z.tickTextAnchor]},n.labels=function(t){return arguments.length?(x.label=t[0],p.label=t[1],z.label=t[2],n):[x.label,p.label,z.label]},n.labelAngles=function(t){return arguments.length?(x.labelAngle=t[0],p.labelAngle=t[1],z.labelAngle=t[2],n):[x.labelAngle,p.labelAngle,z.labelAngle]},n.triangle=function(){return`M${h}L${L}L${C}Z`},n.radius=function(t){return arguments.length?(l=+t,[h,L,C]=s.map((([n,t])=>[n*l,t*l])),x.gridLine=e(C,h),p.gridLine=e(h,L),z.gridLine=e(L,C),n):l},n.scale=function(t){return arguments.length?(o=+t,n.transform(),n):o},n.translate=function(t){return arguments.length?(a=t[0],u=t[1],n.transform(),n):[a,u]},n.transform=function(t){t&&(a=t.x,u=t.y,o=t.k);const[e,i]=s,[r,l]=s.map((([n,t])=>[n*o+a,t*o+u]));l[1]<i[1]+1e-6?u+=i[1]-l[1]:r[1]>e[1]&&(u-=r[1]-e[1]);const g=d(r[1]),k=b(r[1]);r[0]>g+1e-6?a-=r[0]-g:r[0]<k-1e-6&&(a+=k-r[0]);const f=s.map((([n,t])=>[n*o+a,t*o+u]));return c.vertices(f),n},n.transformFromDomains=function(n){const[t,e,i]=n,r=[...new Set(n.map((n=>Math.abs(n[1]-n[0]))))][0],c={};c.k=100/r;const l=function(n){return(n-1)/(3*n)*100}(o),a=l-t[0],u=l-e[0],g=l-i[0],[k,f,m]=s,[A,d]=[k[0]*a+f[0]*u+m[0]*g,k[1]*a+f[1]*u+m[1]*g].map((n=>n/100*c.k));return c.x=A,c.y=d,c},n.domainsFromVertices=function(n){const[e,i,r]=s.map(n.invert);return[[i[0],e[0]].map(t),[r[1],i[1]].map(t),[e[2],r[2]].map(t)]},n}function t(n){return 100*(n>.999999?1:n<1e-6?0:n)}function e([n,t],[e,i]){return function(r){return[n+r*(e-n),t+r*(i-t)]}}function i([n,t],[e,i]){return(i-t)/(e-n)}function r(n,t){return function(e){return(e-t)/n}}function c(){const{sin:n,cos:t,PI:e}=Math,i=e/180;let r=n=>n[0],c=n=>n[1],l=n=>n[2];let[o,a,u]=[-90,150,30].map((e=>[t(e*i),n(e*i)]));function s(n){const t=[r(n),c(n),l(n)],e=d3.sum(t);return 0===e?[0,0,0]:t.map((n=>n/e))}function g(n){const[t,e,i]=s(n);return[o[0]*t+a[0]*e+u[0]*i,o[1]*t+a[1]*e+u[1]*i]}return g.invert=function([n,t]){const[e,i]=o,[r,c]=a,[l,s]=u,g=c-s,k=l-r,f=e-l,m=n-l,A=t-s,d=g*f+k*(i-s),b=(g*m+k*A)/d,h=((s-i)*m+f*A)/d;return[b,h,1-b-h]},g.a=function(n){return arguments.length?(r=n,g):r},g.b=function(n){return arguments.length?(c=n,g):c},g.c=function(n){return arguments.length?(l=n,g):l},g.normalize=s,g.vertices=function(n){return arguments.length?(o=n[0],a=n[1],u=n[2],g):[o,a,u]},g}export{c as ternary,n as ternaryPlot};
